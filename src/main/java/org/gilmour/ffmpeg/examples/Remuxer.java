package org.gilmour.ffmpeg.examples;

import org.bytedeco.javacpp.PointerPointer;
import org.bytedeco.javacpp.avcodec;
import org.gilmour.ffmpeg.util.FFmpegLibLoader;

import static org.bytedeco.javacpp.avcodec.*;
import static org.bytedeco.javacpp.avformat.*;
import static org.bytedeco.javacpp.avutil.*;

/**
 * Created by gilmour on 24.02.2016.
 *
 * @see <a href="https://ffmpeg.org/doxygen/trunk/doc_2examples_2remuxing_8c-example.html">remuxing.c</a>
 */
public class Remuxer {

    // input-output file
    public static final String in_filename = "/home/alicana/Videos/HD-720p.mp4";

    public static final String out_filename = "/home/alicana/Videos/HD-720p_copy.mp4";

    // ====================== Load ffmpeg libraries ======================

    static {
	try {
	    FFmpegLibLoader.tryLoad();
	} catch (FFmpegLibLoader.Exception e) {
	    e.printStackTrace();
	}
    }

    public static class Exception extends java.lang.Exception {

	public Exception(String message) {

	    super(message);
	}

	public Exception(String message, Throwable cause) {

	    super(message, cause);
	}
    }

    // ====================== Main ======================

    public static void main(String[] args) throws Exception {

	AVOutputFormat ofmt = null;
	AVFormatContext ifmt_ctx = new AVFormatContext(null);
	AVFormatContext ofmt_ctx = new AVFormatContext(null);
	AVPacket pkt = new AVPacket();
	int ret, i;

	AVInputFormat f = new AVInputFormat(null);
	AVDictionary options = new AVDictionary(null);
	if ((ret = avformat_open_input(ifmt_ctx, in_filename, f, options)) < 0) {
	    av_dict_set(options, "pixel_format", null, 0);
	    if ((ret = avformat_open_input(ifmt_ctx, in_filename, f, options)) < 0) {
		throw new Exception(
				"avformat_open_input() error " + ret + ": Could not open input \"" + in_filename + "\". (Has setFormat() been called?)");
	    }
	}

	av_dict_free(options);

	if ((ret = avformat_find_stream_info(ifmt_ctx, (PointerPointer) null)) < 0) {
	    throw new Exception("Failed to retrieve input stream information");
	}

	av_dump_format(ifmt_ctx, 0, in_filename, 0);

	if (avformat_alloc_output_context2(ofmt_ctx, null, "mp4", out_filename) < 0) {
	    ret = AVERROR_UNKNOWN;
	    throw new Exception("Could not create output context\n");
	}

	ofmt = ofmt_ctx.oformat();
	//	ofmt_ctx.filename().putString(out_filename);

	int vid_st_idx = -1, aud_st_idx = -1;
	for (i = 0; i < ifmt_ctx.nb_streams(); i++) {

	    AVStream in_stream = ifmt_ctx.streams(i);

	    if (vid_st_idx == -1 && ifmt_ctx.streams(i).codec().codec_type() == AVMEDIA_TYPE_VIDEO) {

		AVCodec codec = avcodec_find_decoder(ifmt_ctx.streams(i).codec().codec_id());
		if (codec == null) {
		    throw new Exception("avcodec_find_decoder() error: Unsupported video format or codec not found: " + ifmt_ctx.streams(i).codec().codec_id()
				    + ".");
		}

		options = new AVDictionary(null);

		// Open video codec
		if ((ret = avcodec_open2(ifmt_ctx.streams(i).codec(), codec, options)) < 0) {
		    throw new Exception("avcodec_open2() error " + ret + ": Could not open video codec.");
		}
		av_dict_free(options);

		// Hack to correct wrong frame rates that seem to be generated by some codecs
		if (ifmt_ctx.streams(i).codec().time_base().num() > 1000 && ifmt_ctx.streams(i).codec().time_base().den() == 1) {
		    ifmt_ctx.streams(i).codec().time_base().den(1000);
		}

		vid_st_idx = i;

		AVStream out_stream = avformat_new_stream(ofmt_ctx, in_stream.codec().codec());

		if (out_stream == null) {
		    ret = AVERROR_UNKNOWN;
		    throw new Exception("Failed allocating output stream\n");
		}

		ret = avcodec_copy_context(out_stream.codec(), in_stream.codec());
		if (ret < 0) {
		    throw new Exception("Failed to copy context from input to output stream codec context\n");
		}

		//		if (ifmt_ctx.duration() == AV_NOPTS_VALUE) {
		//		    if (in_stream.duration() != AV_NOPTS_VALUE) {
		//			//m_in_end_time = (ifmt_ctx->streams[m_in_vid_strm_idx]->duration)/(AV_TIME_BASE);
		//			//			m_in_end_time = (in_stream.duration()) / (in_stream.time_base().den() / in_stream.time_base().num());
		//		    }
		//
		//		} else {
		//		    //		    m_in_end_time = (ifmt_ctx->duration)/(AV_TIME_BASE);
		//		}

		int m_fps = 25; // default value

		if (in_stream.r_frame_rate().num() != AV_NOPTS_VALUE && in_stream.r_frame_rate().den() != 0) {
		    m_fps = (in_stream.r_frame_rate().num()) / (in_stream.r_frame_rate().den());
		}

		out_stream.codec().codec_tag(0);

		out_stream.sample_aspect_ratio().den(out_stream.codec().sample_aspect_ratio().den());
		out_stream.sample_aspect_ratio().num(in_stream.codec().sample_aspect_ratio().num());
		out_stream.codec().codec_id(in_stream.codec().codec_id());
		out_stream.codec().time_base().num(1);
		out_stream.codec().time_base().den(m_fps * (in_stream.codec().ticks_per_frame()));

//		out_stream.codec().width(640);
//		out_stream.codec().height(360);

		out_stream.time_base().num(1);
		out_stream.time_base().den(1000);
		out_stream.r_frame_rate().num(m_fps);
		out_stream.r_frame_rate().den(1);
		out_stream.avg_frame_rate().den(1);
		out_stream.avg_frame_rate().num(m_fps);
		//		out_stream.duration() = (m_out_end_time - m_out_start_time)*1000;

		if ((ofmt_ctx.oformat().flags() & AVFMT_GLOBALHEADER) != 0) {
		    out_stream.codec().flags(out_stream.codec().flags() | CODEC_FLAG_GLOBAL_HEADER);
		}

	    }

	    if (aud_st_idx == -1 && ifmt_ctx.streams(i).codec().codec_type() == AVMEDIA_TYPE_AUDIO) {

		aud_st_idx = i;
	    }

	}

	av_dump_format(ofmt_ctx, 0, out_filename, 1);

	if ((ofmt.flags() & AVFMT_NOFILE) == 0) {
	    AVIOContext pb = new AVIOContext(null);
	    ret = avio_open(pb, out_filename, AVIO_FLAG_WRITE);
	    if (ret < 0) {
		throw new Exception("Could not open output file '%s'" + out_filename);
	    }
	    ofmt_ctx.pb(pb);
	}

	AVDictionary out_opts = new AVDictionary(null);
	ret = avformat_write_header(ofmt_ctx, out_opts);
	if (ret < 0) {
	    throw new Exception("Error occurred when opening output file\n");
	}
	av_dict_free(out_opts);

	long t1 = System.currentTimeMillis();
	while (true) {
	    AVStream in_stream, out_stream;

	    //	    if ((System.currentTimeMillis() - t1) > 5000)
	    //		break;

	    ret = av_read_frame(ifmt_ctx, pkt);
	    if (ret < 0)
		break;

	    in_stream = ifmt_ctx.streams(pkt.stream_index());
	    out_stream = ofmt_ctx.streams(pkt.stream_index());

	    if (in_stream.codec().codec_type() == AVMEDIA_TYPE_VIDEO) {


	        /* copy packet */
		pkt.pts(av_rescale_q_rnd(pkt.pts(), in_stream.codec().time_base(), out_stream.codec().time_base(), AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
		pkt.dts(av_rescale_q_rnd(pkt.dts(), in_stream.codec().time_base(), out_stream.codec().time_base(), AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
		pkt.duration((int) av_rescale_q(pkt.duration(), in_stream.codec().time_base(), out_stream.codec().time_base()));
		pkt.pos(-1);

		ret = av_write_frame(ofmt_ctx, pkt);
		if (ret < 0) {
		    throw new Exception("Error muxing packet\n");
		}
		av_free_packet(pkt);

	    }
	}

	av_write_trailer(ofmt_ctx);

	avformat_close_input(ifmt_ctx);

    /* close output */
	if (!ofmt_ctx.isNull()) {
	    if ((ofmt_ctx.oformat().flags() & AVFMT_NOFILE) == 0) {
		/* close the output file */
		avio_close(ofmt_ctx.pb());
	    }
	}
	avformat_free_context(ofmt_ctx);

	if (ret < 0 && ret != AVERROR_EOF) {
	    throw new Exception("Error occurred: %s\n");
	}

    }

}
